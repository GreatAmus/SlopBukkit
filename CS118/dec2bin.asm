; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	Z:\CS118\dec2bin.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG6136	DB	'%d', 00H
	ORG $+1
$SG6139	DB	'%s', 0dH, 0aH, 00H
	ORG $+3
$SG6161	DB	'%d', 00H
	ORG $+1
$SG6176	DB	'strange, there shouldn''t be something that isn''t zero '
	DB	'or one in here...', 0aH, 00H
CONST	ENDS
_DATA	SEGMENT
___vector_growth DD 040000000r			; 2
_DATA	ENDS
PUBLIC	?dec2bin@@YAXPAUchar_vector@@H@Z		; dec2bin
PUBLIC	_main
EXTRN	_free:PROC
EXTRN	_printf:PROC
EXTRN	_malloc:PROC
EXTRN	_sscanf:PROC
; Function compile flags: /Odtp
; File z:\cs118\dec2bin.c
_TEXT	SEGMENT
_v$6299 = -60						; size = 12
$T6294 = -48						; size = 12
$T6293 = -28						; size = 12
_out$ = -16						; size = 12
_in$ = -4						; size = 4
_argc$ = 8						; size = 4
_args$ = 12						; size = 4
_main	PROC

; 9    : int main(int argc, char ** args) {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH

; 10   : 	
; 11   : 	int in;
; 12   : 	sscanf(args[1], "%d", &in);

	lea	eax, DWORD PTR _in$[ebp]
	push	eax
	push	OFFSET $SG6136
	mov	ecx, DWORD PTR _args$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	call	_sscanf
	add	esp, 12					; 0000000cH

; 13   : 	
; 14   : 	char_vector out = char_vector_create(4);

	push	4
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _v$6299[ebp], eax
	mov	DWORD PTR _v$6299[ebp+4], 0
	mov	DWORD PTR _v$6299[ebp+8], 4
	mov	eax, DWORD PTR _v$6299[ebp]
	mov	DWORD PTR $T6294[ebp], eax
	mov	ecx, DWORD PTR _v$6299[ebp+4]
	mov	DWORD PTR $T6294[ebp+4], ecx
	mov	edx, DWORD PTR _v$6299[ebp+8]
	mov	DWORD PTR $T6294[ebp+8], edx
	mov	eax, DWORD PTR $T6294[ebp]
	mov	DWORD PTR $T6293[ebp], eax
	mov	ecx, DWORD PTR $T6294[ebp+4]
	mov	DWORD PTR $T6293[ebp+4], ecx
	mov	edx, DWORD PTR $T6294[ebp+8]
	mov	DWORD PTR $T6293[ebp+8], edx
	mov	eax, DWORD PTR $T6293[ebp]
	mov	DWORD PTR _out$[ebp], eax
	mov	ecx, DWORD PTR $T6293[ebp+4]
	mov	DWORD PTR _out$[ebp+4], ecx
	mov	edx, DWORD PTR $T6293[ebp+8]
	mov	DWORD PTR _out$[ebp+8], edx

; 15   : 	
; 16   : 	dec2bin(&out, in);

	mov	eax, DWORD PTR _in$[ebp]
	push	eax
	lea	ecx, DWORD PTR _out$[ebp]
	push	ecx
	call	?dec2bin@@YAXPAUchar_vector@@H@Z	; dec2bin
	add	esp, 8

; 17   : 	
; 18   : 	printf("%s\r\n", out.data);

	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	push	OFFSET $SG6139
	call	_printf
	add	esp, 8

; 19   : 	
; 20   : 	char_vector_free_stack(&out);

	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_free
	add	esp, 4

; 21   : 	
; 22   : 	return 0;

	xor	eax, eax

; 23   : 	
; 24   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
PUBLIC	_char_vector_insert
PUBLIC	_char_vector_remove_range
PUBLIC	_char_vector_grow
PUBLIC	__real@4000000000000000
EXTRN	_sprintf:PROC
EXTRN	_pow:PROC
EXTRN	_abs:PROC
EXTRN	__fltused:DWORD
EXTRN	__ftol2_sse:PROC
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
; Function compile flags: /Odtp
CONST	ENDS
_TEXT	SEGMENT
tv158 = -76						; size = 4
tv142 = -72						; size = 4
tv285 = -68						; size = 4
tv256 = -64						; size = 4
tv347 = -60						; size = 8
tv72 = -52						; size = 8
tv238 = -44						; size = 4
$T6328 = -40						; size = 4
$T6310 = -29						; size = 1
$T6309 = -28						; size = 4
_carrybit$6178 = -24					; size = 2
_i$6166 = -20						; size = 4
_order$ = -16						; size = 2
_old_in$ = -12						; size = 4
_tmp$ = -8						; size = 4
_res$ = -4						; size = 2
_out$ = 8						; size = 4
_in$ = 12						; size = 4
?dec2bin@@YAXPAUchar_vector@@H@Z PROC			; dec2bin

; 26   : void dec2bin(char_vector* out, register int in) {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH

; 27   : 	register int old_in = in;

	mov	eax, DWORD PTR _in$[ebp]
	mov	DWORD PTR _old_in$[ebp], eax

; 28   : 	in = (int)abs(in);

	mov	ecx, DWORD PTR _in$[ebp]
	push	ecx
	call	_abs
	add	esp, 4
	mov	DWORD PTR _in$[ebp], eax

; 29   : 	
; 30   : 	char * tmp = (char*)malloc(sizeof(char)*2);

	push	2
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _tmp$[ebp], eax

; 31   : 	register short int order = 0;

	xor	edx, edx
	mov	WORD PTR _order$[ebp], dx
$LN27@dec2bin:

; 32   : 	
; 33   : 	while(pow(2.0,(double)order++)<=(double)in) { }

	movsx	eax, WORD PTR _order$[ebp]
	mov	DWORD PTR tv238[ebp], eax
	fild	DWORD PTR tv238[ebp]
	fstp	QWORD PTR tv72[ebp]
	fild	DWORD PTR _in$[ebp]
	sub	esp, 8
	fld	QWORD PTR tv72[ebp]
	fstp	QWORD PTR [esp]
	sub	esp, 8
	fld	QWORD PTR __real@4000000000000000
	fstp	QWORD PTR [esp]
	fstp	QWORD PTR tv347[ebp]
	call	_pow
	add	esp, 16					; 00000010H
	fld	QWORD PTR tv347[ebp]
	fcompp
	fnstsw	ax
	mov	cx, WORD PTR _order$[ebp]
	add	cx, 1
	mov	WORD PTR _order$[ebp], cx
	test	ah, 1
	jne	SHORT $LN26@dec2bin
	jmp	SHORT $LN27@dec2bin
$LN26@dec2bin:

; 34   : 	
; 35   : 	--order;

	mov	dx, WORD PTR _order$[ebp]
	sub	dx, 1
	mov	WORD PTR _order$[ebp], dx
$LN25@dec2bin:

; 36   : 	
; 37   : 	register short res;
; 38   : 	while(--order>=0) {

	mov	ax, WORD PTR _order$[ebp]
	sub	ax, 1
	mov	WORD PTR _order$[ebp], ax
	movsx	ecx, WORD PTR _order$[ebp]
	test	ecx, ecx
	jl	$LN24@dec2bin

; 39   : 		res = in/(int)pow(2.0,(double)order);

	movsx	edx, WORD PTR _order$[ebp]
	mov	DWORD PTR tv256[ebp], edx
	fild	DWORD PTR tv256[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	sub	esp, 8
	fld	QWORD PTR __real@4000000000000000
	fstp	QWORD PTR [esp]
	call	_pow
	add	esp, 16					; 00000010H
	call	__ftol2_sse
	mov	ecx, eax
	mov	eax, DWORD PTR _in$[ebp]
	cdq
	idiv	ecx
	mov	WORD PTR _res$[ebp], ax

; 40   : 		sprintf(tmp,"%d",res);

	movsx	edx, WORD PTR _res$[ebp]
	push	edx
	push	OFFSET $SG6161
	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 41   : 		char_vector_push_back(out,tmp[0]);

	mov	ecx, DWORD PTR _tmp$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR $T6310[ebp], dl
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR $T6309[ebp], eax
	mov	ecx, DWORD PTR $T6309[ebp]
	mov	edx, DWORD PTR $T6309[ebp]
	mov	eax, DWORD PTR [ecx+8]
	cmp	eax, DWORD PTR [edx+4]
	ja	SHORT $LN30@dec2bin
	mov	ecx, DWORD PTR $T6309[ebp]
	push	ecx
	call	_char_vector_grow
	add	esp, 4
	mov	DWORD PTR $T6309[ebp], eax
$LN30@dec2bin:
	mov	edx, DWORD PTR $T6309[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR $T6309[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	cl, BYTE PTR $T6310[ebp]
	mov	BYTE PTR [eax+edx], cl
	mov	edx, DWORD PTR $T6309[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	eax, 1
	mov	ecx, DWORD PTR $T6309[ebp]
	mov	DWORD PTR [ecx+4], eax

; 42   : 		if(res==1)

	movsx	edx, WORD PTR _res$[ebp]
	cmp	edx, 1
	jne	SHORT $LN23@dec2bin

; 43   : 			in-=(int)pow(2.0, (double)order);

	movsx	eax, WORD PTR _order$[ebp]
	mov	DWORD PTR tv285[ebp], eax
	fild	DWORD PTR tv285[ebp]
	sub	esp, 8
	fstp	QWORD PTR [esp]
	sub	esp, 8
	fld	QWORD PTR __real@4000000000000000
	fstp	QWORD PTR [esp]
	call	_pow
	add	esp, 16					; 00000010H
	call	__ftol2_sse
	mov	ecx, DWORD PTR _in$[ebp]
	sub	ecx, eax
	mov	DWORD PTR _in$[ebp], ecx
$LN23@dec2bin:

; 44   : 	}

	jmp	$LN25@dec2bin
$LN24@dec2bin:

; 45   : 	
; 46   : 	if(old_in<0) {

	cmp	DWORD PTR _old_in$[ebp], 0
	jge	$LN22@dec2bin

; 47   : 		register int i;
; 48   : 		for(i = 0; i < out->length; ++i) {

	mov	DWORD PTR _i$6166[ebp], 0
	jmp	SHORT $LN21@dec2bin
$LN20@dec2bin:
	mov	edx, DWORD PTR _i$6166[ebp]
	add	edx, 1
	mov	DWORD PTR _i$6166[ebp], edx
$LN21@dec2bin:
	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR _i$6166[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jae	SHORT $LN19@dec2bin

; 49   : 			switch(out->data[i]) {

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$6166[ebp]
	mov	dl, BYTE PTR [eax+ecx]
	mov	BYTE PTR tv142[ebp], dl
	cmp	BYTE PTR tv142[ebp], 48			; 00000030H
	je	SHORT $LN16@dec2bin
	cmp	BYTE PTR tv142[ebp], 49			; 00000031H
	je	SHORT $LN14@dec2bin
	jmp	SHORT $LN15@dec2bin
$LN16@dec2bin:

; 50   : 				case '0':
; 51   : 					out->data[i] = '1';

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$6166[ebp]
	mov	BYTE PTR [ecx+edx], 49			; 00000031H

; 52   : 					break;

	jmp	SHORT $LN17@dec2bin
$LN15@dec2bin:

; 53   : 				default:
; 54   : 					printf("strange, there shouldn't be something that isn't zero or one in here...\n");

	push	OFFSET $SG6176
	call	_printf
	add	esp, 4
$LN14@dec2bin:

; 55   : 				case '1':
; 56   : 					out->data[i] = '0';

	mov	eax, DWORD PTR _out$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _i$6166[ebp]
	mov	BYTE PTR [ecx+edx], 48			; 00000030H
$LN17@dec2bin:

; 57   : 					break;
; 58   : 			}
; 59   : 		}

	jmp	SHORT $LN20@dec2bin
$LN19@dec2bin:

; 60   : 		/* add one */
; 61   : 		register short int carrybit = 1;

	mov	eax, 1
	mov	WORD PTR _carrybit$6178[ebp], ax

; 62   : 		for(i = out->length - 1; i >= 0 && carrybit != 0; --i) {

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, 1
	mov	DWORD PTR _i$6166[ebp], edx
	jmp	SHORT $LN13@dec2bin
$LN12@dec2bin:
	mov	eax, DWORD PTR _i$6166[ebp]
	sub	eax, 1
	mov	DWORD PTR _i$6166[ebp], eax
$LN13@dec2bin:
	cmp	DWORD PTR _i$6166[ebp], 0
	jl	SHORT $LN11@dec2bin
	movsx	ecx, WORD PTR _carrybit$6178[ebp]
	test	ecx, ecx
	je	SHORT $LN11@dec2bin

; 63   : 			switch(out->data[i]) {

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$6166[ebp]
	mov	dl, BYTE PTR [eax+ecx]
	mov	BYTE PTR tv158[ebp], dl
	cmp	BYTE PTR tv158[ebp], 49			; 00000031H
	je	SHORT $LN7@dec2bin

; 64   : 				default:
; 65   : 				case '0':
; 66   : 					carrybit = 0;

	xor	eax, eax
	mov	WORD PTR _carrybit$6178[ebp], ax

; 67   : 					out->data[i] = '1';

	mov	ecx, DWORD PTR _out$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _i$6166[ebp]
	mov	BYTE PTR [edx+eax], 49			; 00000031H

; 68   : 					break;

	jmp	SHORT $LN9@dec2bin
$LN7@dec2bin:

; 69   : 				case '1':
; 70   : 					carrybit = 1;

	mov	ecx, 1
	mov	WORD PTR _carrybit$6178[ebp], cx

; 71   : 					out->data[i] = '0';

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _i$6166[ebp]
	mov	BYTE PTR [eax+ecx], 48			; 00000030H
$LN9@dec2bin:

; 72   : 					break;
; 73   : 			}
; 74   : 		}

	jmp	SHORT $LN12@dec2bin
$LN11@dec2bin:

; 75   : 		/* if the most significant bit is 1, then drop it */
; 76   : 		if(out->data[0]=='1')

	mov	edx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 49					; 00000031H
	jne	SHORT $LN35@dec2bin

; 77   : 			char_vector_remove(out, 0);

	xor	edx, edx
	add	edx, 1
	push	edx
	push	0
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_char_vector_remove_range
	add	esp, 12					; 0000000cH
$LN35@dec2bin:

; 78   : 		/* pad output */
; 79   : 		while((out->length+1)%4!=0) {

	mov	ecx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, 1
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	je	SHORT $LN4@dec2bin

; 80   : 			char_vector_insert(out, 0, '1');

	push	49					; 00000031H
	push	0
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_char_vector_insert
	add	esp, 12					; 0000000cH

; 81   : 		}

	jmp	SHORT $LN35@dec2bin
$LN4@dec2bin:

; 82   : 		char_vector_insert(out, 0, '1');

	push	49					; 00000031H
	push	0
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_char_vector_insert
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN3@dec2bin
$LN22@dec2bin:

; 83   : 	} else {
; 84   : 		while((out->length+1)%4!=0)

	mov	ecx, DWORD PTR _out$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, 1
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	je	SHORT $LN1@dec2bin

; 85   : 			char_vector_insert(out, 0, '0');

	push	48					; 00000030H
	push	0
	mov	edx, DWORD PTR _out$[ebp]
	push	edx
	call	_char_vector_insert
	add	esp, 12					; 0000000cH
	jmp	SHORT $LN22@dec2bin
$LN1@dec2bin:

; 86   : 		char_vector_insert(out, 0, '0');

	push	48					; 00000030H
	push	0
	mov	eax, DWORD PTR _out$[ebp]
	push	eax
	call	_char_vector_insert
	add	esp, 12					; 0000000cH
$LN3@dec2bin:

; 87   : 	}
; 88   : 		
; 89   : 	char_vector_push_back(out, '\0');

	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR $T6328[ebp], ecx
	mov	edx, DWORD PTR $T6328[ebp]
	mov	eax, DWORD PTR $T6328[ebp]
	mov	ecx, DWORD PTR [edx+8]
	cmp	ecx, DWORD PTR [eax+4]
	ja	SHORT $LN59@dec2bin
	mov	edx, DWORD PTR $T6328[ebp]
	push	edx
	call	_char_vector_grow
	add	esp, 4
	mov	DWORD PTR $T6328[ebp], eax
$LN59@dec2bin:
	mov	eax, DWORD PTR $T6328[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR $T6328[ebp]
	mov	eax, DWORD PTR [edx+4]
	mov	BYTE PTR [ecx+eax], 0
	mov	ecx, DWORD PTR $T6328[ebp]
	mov	edx, DWORD PTR [ecx+4]
	add	edx, 1
	mov	eax, DWORD PTR $T6328[ebp]
	mov	DWORD PTR [eax+4], edx

; 90   : 	
; 91   : 	free(tmp);

	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	call	_free
	add	esp, 4

; 92   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dec2bin@@YAXPAUchar_vector@@H@Z ENDP			; dec2bin
_TEXT	ENDS
EXTRN	_realloc:PROC
; Function compile flags: /Odtp
;	COMDAT _char_vector_grow
_TEXT	SEGMENT
tv142 = -48						; size = 8
tv140 = -40						; size = 4
tv137 = -34						; size = 2
tv133 = -32						; size = 8
tv93 = -24						; size = 8
tv91 = -16						; size = 4
tv88 = -10						; size = 2
tv84 = -8						; size = 8
_v$ = 8							; size = 4
_char_vector_grow PROC					; COMDAT

; 5    : VECTOR_PROTOTYPE(char, char);

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv84[ebp], ecx
	mov	DWORD PTR tv84[ebp+4], 0
	fild	QWORD PTR tv84[ebp]
	fmul	DWORD PTR ___vector_growth
	fnstcw	WORD PTR tv88[ebp]
	movzx	eax, WORD PTR tv88[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv91[ebp], eax
	fldcw	WORD PTR tv91[ebp]
	fistp	QWORD PTR tv93[ebp]
	fldcw	WORD PTR tv88[ebp]
	mov	edx, DWORD PTR tv93[ebp]
	push	edx
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	_realloc
	add	esp, 8
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR tv133[ebp], ecx
	mov	DWORD PTR tv133[ebp+4], 0
	fild	QWORD PTR tv133[ebp]
	fmul	DWORD PTR ___vector_growth
	fnstcw	WORD PTR tv137[ebp]
	movzx	eax, WORD PTR tv137[ebp]
	or	eax, 3072				; 00000c00H
	mov	DWORD PTR tv140[ebp], eax
	fldcw	WORD PTR tv140[ebp]
	fistp	QWORD PTR tv142[ebp]
	fldcw	WORD PTR tv137[ebp]
	mov	edx, DWORD PTR tv142[ebp]
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _v$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
_char_vector_grow ENDP
_TEXT	ENDS
EXTRN	_memmove:PROC
; Function compile flags: /Odtp
;	COMDAT _char_vector_insert
_TEXT	SEGMENT
_v$ = 8							; size = 4
_idx$ = 12						; size = 4
_t$ = 16						; size = 1
_char_vector_insert PROC				; COMDAT

; 5    : VECTOR_PROTOTYPE(char, char);

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	ja	SHORT $LN1@char_vecto
	mov	eax, DWORD PTR _v$[ebp]
	push	eax
	call	_char_vector_grow
	add	esp, 4
	mov	DWORD PTR _v$[ebp], eax
$LN1@char_vecto:
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, DWORD PTR _idx$[ebp]
	push	edx
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR _idx$[ebp]
	push	ecx
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _idx$[ebp]
	lea	edx, DWORD PTR [eax+ecx+1]
	push	edx
	call	_memmove
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _v$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _idx$[ebp]
	mov	al, BYTE PTR _t$[ebp]
	mov	BYTE PTR [ecx+edx], al
	pop	ebp
	ret	0
_char_vector_insert ENDP
_TEXT	ENDS
EXTRN	_memcpy:PROC
EXTRN	_calloc:PROC
; Function compile flags: /Odtp
;	COMDAT _char_vector_remove_range
_TEXT	SEGMENT
_tmp$ = -4						; size = 4
_v$ = 8							; size = 4
_begin$ = 12						; size = 4
_end$ = 16						; size = 4
_char_vector_remove_range PROC				; COMDAT

; 5    : VECTOR_PROTOTYPE(char, char);

	push	ebp
	mov	ebp, esp
	push	ecx
	push	1
	mov	eax, DWORD PTR _v$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, DWORD PTR _end$[ebp]
	push	ecx
	call	_calloc
	add	esp, 8
	mov	DWORD PTR _tmp$[ebp], eax
	mov	edx, DWORD PTR _v$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, DWORD PTR _end$[ebp]
	push	edx
	mov	eax, DWORD PTR _tmp$[ebp]
	push	eax
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, DWORD PTR _begin$[ebp]
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _end$[ebp]
	sub	eax, DWORD PTR _begin$[ebp]
	mov	ecx, DWORD PTR _v$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	sub	edx, eax
	mov	eax, DWORD PTR _v$[ebp]
	mov	DWORD PTR [eax+4], edx
	mov	ecx, DWORD PTR _tmp$[ebp]
	push	ecx
	call	_free
	add	esp, 4
	mov	esp, ebp
	pop	ebp
	ret	0
_char_vector_remove_range ENDP
_TEXT	ENDS
END
